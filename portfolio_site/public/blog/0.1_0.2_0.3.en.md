# 0.1 + 0.2 ≠ 0.3

Computers use binary, humans use decimal, and because of that, the numbers we work with don’t always line up perfectly. Here’s something interesting I ran into today.

In decimal, whether a fraction $\frac{p}{q}$ can be written as a **finite** decimal depends on whether the denominator \(q\) has only the prime factors 2 and 5, since $10 = 2 \times 5.$

So for example: $\frac{1}{2}, \frac{1}{4}, \frac{1}{5}, \frac{1}{10}, \frac{1}{20}$ all become clean, finite decimals.

But:
$\frac{1}{3}, \frac{1}{6}, \frac{1}{7}$ turn into infinite repeating decimals.

Binary works the same way, except the base is 2. This means that if you want a number to have a **finite binary** representation, the denominator has to be made up of only the prime factor 2.

So:
$\frac{1}{2}, \frac{1}{4}, \frac{1}{8}, \frac{1}{16}$ can all be stored exactly by a computer.
But values like $0.1,0.2,0.3$
can’t be represented perfectly — in binary they’re actually infinite repeating decimals.

It’s basically the computer version of writing $\frac{1}{3} = 0.3333\ldots$
where you just chop it off somewhere, and that little truncation introduces small precision errors.

So we can experiment:
```python
print(0.1 + 0.2 - 0.3)

"""
5.551115123125783e-17
"""
```
In this situation:  
$0.1 + 0.2 \neq 0.3$, meaning that `0.1 + 0.2 == 0.3` will return `False`.

So when we use computers to perform precise numerical calculations — especially when we need to check whether something equals 0 — we need to clarify the following: when a value is extremely close to 0, under what level of precision do we *treat* it as 0?

By convention, the tolerance `tol` is usually set to $10^{-12}$, which means:  
`tol = 1e-12`.

Now let’s try the $0.1 + 0.2$ example again.
```python
tol = 1e-12
print(abs(0.1 + 0.2 - 0.3)< tol)

"""
True
"""
```
Good.  
Now let’s apply this idea in practice. I’ll use RREF (Row Reduced Echelon Form) as an example:

```python
def rref(A, tol = 1e-12):
    A = A.astype(float)
    m, n = A.shape
    r = 0                     
    for c in range(n):      
        if r >= m:
            break
        pivot = None
        for i in range(r, m):
            if abs(A[i, c]) < tol:
                pivot = i
                break
        if pivot is None:
            continue
        if pivot != r:
            A[[r, pivot]] = A[[pivot, r]]
        A[r] = A[r] / A[r, c]
        for i in range(m):
            if i != r:
                A[i] = A[i] - A[i, c] * A[r]
        r += 1               
    print(A)
```
Here’s the RREF code — we’re actually learning this in my linear algebra class right now, so I thought it’d be fun to implement it in code. This is a good place to see how tolerance is used in precision checks.  
Suppose we have:
```python
if __name__ == '__main__':
    import numpy as np
    array = np.array([
        [1, 1],
        [1, 1 + 10 ** (-14)]])
    rref(array)
```
With `tol = 1e-12`, this value will be considered 0.  
But if `tol = 1e-15`, then the same value will now be treated as the pivot (the index of the second column), and the result will be different.

This is exactly why we can’t use `A[i, c] != 0`.  
No matter how small a number is — for example $10^{-100}$ — it will *never* equal 0 inside a binary computer.

Shout out to: 
[https://0.30000000000000004.com](https://0.30000000000000004.com)

<p align="center">
<img src= 'assets/reddit_screenshot.png'
width=""/>
</p>

---
A bit more about the RREF code — it’s actually pretty clever. But when we do RREF by hand with pen and paper, we’re basically following the same logic as a computer. We go column by column, and if `(if bs(A[i, c]) < tol)` — meaning the index number is 0 — then we swap rows.

```python
def rref(A, tol = 1e-12):
    A = A.astype(float)
    # Convert to float first to avoid decimals being truncated during computation

    m, n = A.shape
    r = 0  
    # After converting to RREF, the leading 1s form a diagonal; stop when r = m

    for c in range(n):      
        if r >= m:
            break

        pivot = None
        for i in range(r, m):
            if abs(A[i, c]) < tol:
                pivot = i
                break
        # Check if the entry is effectively 0; if so, keep looking

        if pivot is None:
            continue
        # Means the entire column is 0 — skip this column

        if pivot != r:
            A[[r, pivot]] = A[[pivot, r]]
        # Swap rows if the pivot row is different
        # This is NumPy’s fancy indexing — swaps row r and the pivot row

        A[r] = A[r] / A[r, c]
        # Divide the pivot row by its pivot entry to make the pivot equal to 1

        for i in range(m):
            if i != r:
                A[i] = A[i] - A[i, c] * A[r]
        # For every other row, eliminate the entry in this column

        r += 1               
    print(A)
```

*2025.11.14*  
*Written in the Row 6 / Col 3 cubicle on the left side of the second floor of the Reg, University of Chicago*
