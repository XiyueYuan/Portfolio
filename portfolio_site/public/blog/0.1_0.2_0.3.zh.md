# 0.1 + 0.2 ≠ 0.3

计算机中使用的二进制和人类世界使用的10进制，会在数值上产生差距，下面分享一个我今天看到的有趣的东西。

在十进制中，一个分数 $\frac{p}{q}$ 能否表示成有限小数，取决于 $q$ 的质因子是否只包含2和5，$10 = 2\times5$
所以： 
- $\frac{1}{2}, \frac{1}{4}, \frac{1}{5}, \frac{1}{10}, \frac{1}{20}$ 都能表示成有限小数
- $\frac{1}{3}, \frac{1}{6}, \frac{1}{7}$ 会变成无限循环小数

在二进制中，是同样的道理，这里基数就是2，也就是说，如果想要成为有限二进制小数，分母 $q$ 的质因子必须只包含2
所以：
- $\frac{1}{2}, \frac{1}{4}, \frac{1}{8}, \frac{1}{16}$ 可以被电脑精确表示（可以存有限的小数位）
- 0.1, 0.2, 0.3 这些就不能在二进制中被“完整”且精确的储存了，这些在计算机中都是无限循环小数，类似于 $\frac{1}{3}$，人类世界中用 $0.3333...$ 来截断一部分来表示一个不精准的数，计算机中也一样。

所以我们可以实验一下:
```python
print(0.1 + 0.2 - 0.3)

"""
5.551115123125783e-17
"""
```
在这种情况下：
0.1 + 0.2 ≠ 0.3，或者说 `0.1 + 0.2 == 0.3` 会 `return False`

那么在使用计算机做精密的数学计算中，特别是那些需要判断是否=0的时候，我们需要来说明：在一个数非常接近0的时候，在多少精度下，我们人为的认为这个数就是0。惯例来说，tol(tolerance)，会取10的-12次方，也就是
`tol = 1e-12`，那我们现在再试一下刚刚说的 $0.1 + 0.2$ 的问题

```python
tol = 1e-12
print(abs(0.1 + 0.2 - 0.3)< tol)

"""
True
"""
```
这下对了。
我们来实际应用一下，我举RREF(Row Reduced Echelon Form)这个例子:

```python
def rref(A, tol = 1e-12):
    A = A.astype(float)
    m, n = A.shape
    r = 0                     
    for c in range(n):      
        if r >= m:
            break
        pivot = None
        for i in range(r, m):
            if abs(A[i, c]) < tol:
                pivot = i
                break
        if pivot is None:
            continue
        if pivot != r:
            A[[r, pivot]] = A[[pivot, r]]
        A[r] = A[r] / A[r, c]
        for i in range(m):
            if i != r:
                A[i] = A[i] - A[i, c] * A[r]
        r += 1               
    print(A)
```
这是RREF的代码，正好我们线性代数的数学课正在学这个，心血来潮用代码实现一下，在这里可以看精度判断的应用。
假设我们有:
```python
if __name__ == '__main__':
    import numpy as np
    array = np.array([
        [1, 1],
        [1, 1 + 10 ** (-14)]])
    rref(array)
```
那么在 `tol = 1e-12` 的情况下，会把这个值认为是0，如果 `tol = 1e-15`，那么现在这个值就会被认为是第二列的index number，得到的结果就会不一样。这也是为什么不能用 `A[i, c] != 0`，因为无论是多小的数，如：10 ** (-100)，在二进制的电脑中永远不等于0

Shout out to: 
[https://0.30000000000000004.com](https://0.30000000000000004.com)

<p align="center">
<img src= 'assets/reddit_screenshot.png'
width=""/>
</p>

---
关于 RREF 的代码，可以多说两嘴，还挺精妙的，但其实我们人类在用纸笔做的时候，就是计算机的思维，按照列遍历，如果`(if bs(A[i, c]) < tol)`: : index number = 0，那么swap rows。

```python
def rref(A, tol = 1e-12):
    A = A.astype(float)
    # 先转成float，防止运算时小数被截断

    m, n = A.shape
    r = 0  
    # 因为转成rref后1是斜着的，如果 r = m 就停止

    for c in range(n):      
        if r >= m:
            break

        pivot = None
        for i in range(r, m):
            if abs(A[i, c]) < tol:
                pivot = i
                break
        # 看看index是不是0，是就下一个

        if pivot is None:
            continue
        # 说明全是0！这列不管了

        if pivot != r:
            A[[r, pivot]] = A[[pivot, r]]
        # 换一下，如果pivot变了的话
        # 这是numpy的花式索引选择，表示pivot行和r行交换

        A[r] = A[r] / A[r, c]
        # 除一下自己，index得到1

        for i in range(m):
            if i != r:
                A[i] = A[i] - A[i, c] * A[r]
        # 每一行看一下，是不是要变成0

        r += 1               
    print(A)
```

*2025.11.14*
*写于芝加哥大学Reg图书馆四楼左边Row 6/Col 3的cubic里*